import pandas as pd
import pint
import pint_pandas
import numpy as np
u = ureg =pint.UnitRegistry()
pint_pandas.PintType.ureg = u
from pint_pandas import PintArray, PintType

import pdb

from pint_pandas.testsuite.test_pandas_extensiontests import TestSetitem
self = TestSetitem()

_all_arithmetic_operators = [
    "__add__",
    "__radd__",
    "__sub__",
    "__rsub__",
    "__mul__",
    "__rmul__",
    "__floordiv__",
    "__rfloordiv__",
    "__truediv__",
    "__rtruediv__",
    "__pow__",
    "__rpow__",
    "__mod__",
    "__rmod__",
]
import pandas._testing as tm

all_arithmetic_operators = "__radd__"

data = PintArray.from_1darray_quantity(np.arange(start=1.0, stop=101.0) * ureg.nm)

# GH#44514
df = pd.DataFrame({"A": data})

# These dtypes have non-broken implementations of _can_hold_element
has_can_hold_element = False

# Avoiding using_array_manager fixture
#  https://github.com/pandas-dev/pandas/pull/44514#discussion_r754002410
using_array_manager = isinstance(df._mgr, pd.core.internals.ArrayManager)

blk_data = df._mgr.arrays[0]

orig = df.copy()

msg = "will attempt to set the values inplace instead"
warn = None
if has_can_hold_element and not isinstance(data.dtype, PandasDtype):
    # PandasDtype excluded because it isn't *really* supported.
    warn = FutureWarning

with tm.assert_produces_warning(warn, match=msg):
    df.iloc[:] = df
self.assert_frame_equal(df, orig)

df.iloc[:-1] = df.iloc[:-1]
self.assert_frame_equal(df, orig)

#if isinstance(data.dtype, DatetimeTZDtype):
#    # no warning bc df.values casts to object dtype
#   warn = None
#df.iloc[:] = df.values
print(df, df.dtypes)
df.iloc[:] = df.values
print(df, df.dtypes)
#self.assert_frame_equal(df, orig)
